#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>

#include <util/delay.h>
#include <util/atomic.h>

#include "defines.h"
#include "lcd.h"
#include "medfilter.h"
#include "iirfilter.h"


// time (in 40ms) which will be waited until the information on the display will be refreshed
#define DISPLAY_REFRESH_TIMEOUT	20
// time (in 40ms) which will be waited until the information on the display will toggled between voltages and current
#define DISPLAY_SWITCH_TIMEOUT	200

// TODO find the right values for the current measurnment
#define ADC_OFFSET				0
// defines mA for one adc change
#define ADC_TO_CURRENT			1
// defines mV for one adc change
#define ADC_TO_VOLTAGE			40
// if the difference of the last update of the eeprom capacity value (in mAh)
// is bigger than that value, the new capacitiy value will be saved
// in the eeprom
// is used to reload the old value, if the avr restarts
#define CAPACITY_UPDATE_DIFF	5000

#define MAX_REMAINING_HOURS		999

#define BATTERY_COUNT			6

// nAh to mAh
#define NAH_TO_MAH				1000000

// normally it should be 136µmin for a prescaler of 64 @2MHz
// but this results in an error of 4,6% of the capacitiy change
// so use a bigger value
// with 142µmin there was an error of -0,06%
#define TIMER0_DELAY_UMIN		142

#define BUFFER_LENGTH			9

// use internal reference voltage
#define AD_STATIC_CONF			( (1<<REFS1) | (1<<REFS0) | (1<<ADLAR) )
// use diffrential input 1+ and 0- with 200x gain
#define ADMUX_CURRENT			(AD_STATIC_CONF | 0b01011)
// use single ended inputs 2 till 7
#define ADMUX_VOLTAGE(offset)	( AD_STATIC_CONF | (0b00010 + offset) )

// the capacitiy (in mAh) before the avr resets
int32_t eeRemainingCapacity EEMEM = 0;
// TODO only for testing
volatile int16_t lastADCValue = 0;
// the current which is running now (in mA)
volatile int32_t current = 0;
// the capacity change of the last mesurments (in nAh)
volatile int32_t capacityDifference = 0;
// voltages of all batteries (in mV)
volatile uint16_t voltages[BATTERY_COUNT];

const uint8_t adcIndexToBatteryNr[] = {1, 2, 4, 6, 8, 9};


FILE lcd_str = FDEV_SETUP_STREAM(lcd_putchar, NULL, _FDEV_SETUP_WRITE);

void updateRemCapacity(int32_t* const remainingCapacity);
void writeRemCapacityToEEPROM(const int32_t remainingCapacity);
void showVoltagesOfAllBatteries(void);
void printVoltage(const uint8_t batteryNr);
void showCurrentAndTime(const int32_t remainingCapacity);
void convertValueToString(const int32_t value, const uint8_t integerPlaces, const uint8_t decimalPlaces, char string[]);


ISR (ADC_vect)
{
	// the adc result will be safed in the timer0 interrupt
	// so no data exchange between this two interrupts is needed
}

// With a prescaler of 64 @2MHz every 8,192ms the interrupt will be called
// so every 16,384ms the current will be measured
ISR (TIMER0_OVF_vect)
{
	static bool isCurrentMeasurement = true;
	static uint8_t lastVoltageMeasurement = 0;
	
	if (isCurrentMeasurement)
	{
		const int16_t newValue = ADC;
		const int16_t medValue = MedFilter_calc(newValue);
		const int16_t iirValue = IIRFilter_calc(medValue);
		
		// calulate the current of the mesurnment (in mA)
		const int16_t adcWithoutOffset = iirValue - ADC_OFFSET;
		current = (int32_t)(adcWithoutOffset) * ADC_TO_CURRENT;
		
		// set up next voltage measurement
		isCurrentMeasurement = false;
		lastVoltageMeasurement = (lastVoltageMeasurement + 1) % BATTERY_COUNT;
		ADMUX = ADMUX_VOLTAGE(lastVoltageMeasurement);
	}
	else
	{
		// save result of last voltage measurment
		voltages[lastVoltageMeasurement] = ADC;
		
		// set up next current measurement
		isCurrentMeasurement = true;
		
		// adc1 => max 64 (wohl 1 bit)
		// TODO testen ob bei ADC0 vs ADC0 200x kein offste 0b01010 => max -128-448
		// ADC0 10x 0b01000 => max 192-256
		// TODO testen mit 10x gain 0b01001 => max 704
		// 200x gain => 2500-7400
		ADMUX = ADMUX_CURRENT;
	}
	
	// capacity difference of this current mesurment (in mAµmin = nAmin)
	int32_t newCapacityDiff = current * TIMER0_DELAY_UMIN;
	// capacity (in nAh)
	newCapacityDiff /= 60;
	// capacitiy difference of the last mesurments (in nAh)
	capacityDifference += newCapacityDiff;
	
	
	const int16_t newValue = TCNT0;
	if (newValue > lastADCValue)
		lastADCValue = newValue;

	// set avr to sleep mode and start adc conversion
	// reduce noise which will be generated by the cpu
	// interrupts have to be enabled before sleeping
	// otherwise the adc interrupt could not wake up the cpu
	sei();
	sleep_mode();
}


int main(void)
{
	lcd_init();
	stdout = &lcd_str;
	
	MedFilter_reset();
	IIRFilter_reset();
	
	// init adc
	//first conversion should be a current detection
	ADMUX = ADMUX_CURRENT;
	// frequency for convertion should be between 50 and 200kHz
	// so use a prescaler of 16 @2MHz
	// Interrupt only activated to wake up the avr from sleep mode, if a conversion is finisched
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (0 << ADPS1) | (0 << ADPS0) | (1 << ADIE);
	// start new conversion
	ADCSRA |= (1 << ADSC);
	
	// Configure sleep mode for adc noise reduction
	set_sleep_mode(SLEEP_MODE_ADC);
	
	// Timer 0 konfigurieren
	TCCR0 = (0 << CS02) | (1 << CS01) | (1 << CS00); // Prescaler 64
	
	// Overflow Interrupt erlauben
	TIMSK |= (1 << TOIE0);
	
	// Global Interrupts aktivieren
	sei();
	
	
	// the remaining capacity of the batteries (in mAh)
	// reload the last value before the reset from the eeprom
	int32_t remainingCapacity = eeprom_read_dword( (uint32_t*)&eeRemainingCapacity );
	
	bool showVoltages = false;
	uint8_t displayTimeout = 0;
	while (true)
	{
		updateRemCapacity(&remainingCapacity);
		writeRemCapacityToEEPROM(remainingCapacity);
		
		// TODO 10%-35% der geladenen kapazität nach beendigung des ladens abziehen
		// da blei akkus nur 65%-90% wirkungsgrad haben
		// http://de.statista.com/statistik/daten/studie/156269/umfrage/wirkungsgrade-von-ausgewaehlten-stromspeichern/
		
		
		if ( (displayTimeout % DISPLAY_REFRESH_TIMEOUT) == 0 )
		{
			// show the requestet informations on the lcd
			if (showVoltages)
				showVoltagesOfAllBatteries();
			else
				showCurrentAndTime(remainingCapacity);
		}
		
		
		// toggle between the shown information after a choosen timeout
		if (displayTimeout > DISPLAY_SWITCH_TIMEOUT)
		{
			displayTimeout = 0;
			showVoltages = !showVoltages;
		}
		displayTimeout++;
		
		// use a capacity calulation rate of 25Hz
		// it have to be smaller than 72ms,
		//  because this time is needed to discharge 2mAh @100A
		// 2mAh is nearly the biggest value of the variable capacityDifference
		// 100A * 40ms = 4As * h/(3600s) = 1112 µAh
		_delay_ms(40);
	}
	
	return 0;
}


void updateRemCapacity(int32_t* const remainingCapacity)
{
	// copy remaining capacity from nAh to mAh buffer
	if (capacityDifference > NAH_TO_MAH)
	{
		ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
		{
			capacityDifference -= NAH_TO_MAH;
		}
		(*remainingCapacity)++;
	}
	else if (capacityDifference < -NAH_TO_MAH)
	{
		ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
		{
			capacityDifference += NAH_TO_MAH;
		}
		(*remainingCapacity)--;
	}
	
	// reset capacitiy calulation if the remaning capacitiy is negative and the batteries are charging now
	// possiblly the batteries has grown or was charged externally before
	if (*remainingCapacity < 0 && current > 0)
	{
		*remainingCapacity = 0;
	}
}


void writeRemCapacityToEEPROM(const int32_t remainingCapacity)
{
	static int32_t lastSavedCapacity = 0;
	
	const int32_t capacityDifference = abs(remainingCapacity - lastSavedCapacity);
	if ( capacityDifference > CAPACITY_UPDATE_DIFF )
	{
		eeprom_write_dword( (uint32_t*)&eeRemainingCapacity, remainingCapacity );
		lastSavedCapacity = remainingCapacity;
	}
}


void showVoltagesOfAllBatteries(void)
{
	for (uint8_t i=0; i<(BATTERY_COUNT/2); i++)
	{
		printVoltage(i);
	}
	printf_P( PSTR("\n") );
	
	for (uint8_t i=(BATTERY_COUNT/2); i<BATTERY_COUNT; i++)
	{
		printVoltage(i);
	}
	printf_P( PSTR("\n") );
}


void printVoltage(const uint8_t adcIndex)
{
	// TODO add the indexes of the batteries, because adc index not equal with batterie index
	const uint16_t voltageInVolts = voltages[adcIndex] / ADC_TO_VOLTAGE;
	
	char convertedString[BUFFER_LENGTH];
	convertValueToString(voltageInVolts, 2, 2, convertedString);
	
	const uint8_t batteryNr = adcIndexToBatteryNr[adcIndex];
	printf_P( PSTR("%d:%s "), batteryNr, convertedString );
}


void showCurrentAndTime(const int32_t remainingCapacity)
{
	char convertedString[BUFFER_LENGTH];
	convertValueToString(current, 4, 3, convertedString);
	printf_P( PSTR("%s A   "), convertedString );
	
	convertValueToString(remainingCapacity, 4, 3, convertedString);
	printf_P( PSTR("%s Ah\n"), convertedString );
	
	
//	if (current < 0)
	{
		const uint32_t remainingTimeInMinutes = remainingCapacity * 60 / -current;
		const uint16_t remainingHours = (uint16_t)(remainingTimeInMinutes / 60);
		// only show if there is remaining capacity and the batteries will be discharged
		if (remainingCapacity > 0)// TODO only for testing && remainingHours <= MAX_REMAINING_HOURS)
		{
			const uint8_t remainingMinutes = (uint8_t)(remainingTimeInMinutes % 60);
			printf_P( PSTR("%07d Rem. time: %03d:%02d h\n"), lastADCValue, remainingHours, remainingMinutes );
//			printf_P( PSTR("Rem. time: %04d:%02d h    \n"), remainingHours, remainingMinutes );
		}
		else
		{
			printf_P( PSTR("Rem. time not available.\n") );
		}
	}
/*	else
	{
		printf_P( PSTR("Charging batteries...   \n") );
	}*/
}


void convertValueToString(const int32_t value, const uint8_t integerPlaces, const uint8_t decimalPlaces, char string[])
{
	ltoa(value, string, 10);
	
	// caluclate the length in characters of the resulting string including the decimal point
	const uint8_t stringLength = integerPlaces + decimalPlaces + 1;
	// caluclate the position of the point in the string
	const uint8_t pointPosition = stringLength - decimalPlaces - 1;
	// do not move and not override the first character if it is a minus
	const uint8_t endOfCopiing = (string[0] == '-') ? 1 : 0;
	
	int8_t leftNumbers = strlen(string);
	for (int8_t i=stringLength; i>=endOfCopiing; i--)
	{
		if (i == pointPosition)
		{
			// add the comma to the string
			string[i] = ',';
		}
		else if (leftNumbers >= endOfCopiing)
		{
			// insert converted numbers till the first number (without the minus)
			string[i] = string[leftNumbers];
			leftNumbers--;
		}
		else
		{
			// fill up string with 0
			string[i] = '0';
		}
	}
}
